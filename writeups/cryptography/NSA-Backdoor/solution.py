import gmpy2
from gmpy2 import mpz # For arbitrary precision integers
import math # Not strictly needed with gmpy2 for gcd or pow, but often useful
import primefac # For prime factorization (e.g., pollard_pm1 and general primefac)
from binascii import unhexlify # For converting hex to bytes
import itertools # For iterating over combinations

# --- Custom Wrapper for Modular Exponentiation ---
def powmod_base_list(base, exponent, modulus):
    """
    A wrapper function for gmpy2.pow, providing a custom name for modular exponentiation.
    Calculates (base ** exponent) % modulus efficiently.

    Args:
        base (mpz): The base.
        exponent (mpz): The exponent.
        modulus (mpz): The modulus.

    Returns:
        mpz: The result of (base ** exponent) % modulus.
    """
    return gmpy2.powmod(base, exponent, modulus)


# --- Helper Functions for Discrete Logarithm and CRT ---

def dlog_brute(base, val, modulus, order_limit):
    """
    Solves the discrete logarithm problem: base^x = val (mod modulus) by brute force.
    This function is specifically designed for solving discrete logs within small subgroups
    as required by the Pohlig-Hellman algorithm.

    Args:
        base (mpz): The base of the exponentiation.
        val (mpz): The target value.
        modulus (mpz): The modulus for the discrete logarithm.
        order_limit (mpz): The known order of the `base` element in the group `Z_modulus^*`.
                           The search space for `x` is from 0 to `order_limit - 1`.

    Returns:
        mpz: The integer `x` such that base^x = val (mod modulus).

    Raises:
        ValueError: If no solution is found within the specified `order_limit`.
    """
    # Handle the trivial case where the value is 1 (exponent must be 0)
    if val == 1:
        return mpz(0)
    
    # Ensure all inputs are mpz objects for consistent arbitrary-precision arithmetic
    base = mpz(base)
    val = mpz(val)
    modulus = mpz(modulus)
    order_limit = mpz(order_limit)

    x = mpz(1) # Start checking from x=1
    current_val = base % modulus # Calculate base^1 mod modulus
    
    # Iterate `x` from 1 up to `order_limit - 1`. If `x` reaches `order_limit`,
    # it means all elements in the subgroup generated by `base` have been checked.
    while current_val != val:
        current_val = (current_val * base) % modulus # Compute base^(x+1)
        x += 1
        if x >= order_limit: # If x reaches or exceeds the order limit without finding a solution
            raise ValueError(
                f"No solution found within the specified order limit {order_limit} "
                f"for dlog_brute. Base: {base}, Val: {val}, Modulus: {modulus}"
            )
    return x

def extended_gcd(a, b):
    """
    Implements the Extended Euclidean Algorithm.
    Returns (gcd, x, y) such that a*x + b*y = gcd(a, b).
    This is a helper function used by `mod_inverse`.

    Args:
        a (mpz): First integer.
        b (mpz): Second integer.

    Returns:
        tuple: (gcd, x, y) as mpz objects.
    """
    # Base case for recursion
    if a == 0:
        return b, mpz(0), mpz(1)
    
    # Recursive call
    gcd, x1, y1 = extended_gcd(b % a, a)
    
    # Update x and y using the results from the recursive call
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

def mod_inverse(a, m):
    """
    Computes the modular multiplicative inverse of 'a' modulo 'm'.
    Returns 'x' such that a*x = 1 (mod m).
    Requires 'a' and 'm' to be coprime (i.e., gcd(a, m) = 1).

    Args:
        a (mpz): The number to find the inverse of.
        m (mpz): The modulus.

    Returns:
        mpz: The modular inverse.

    Raises:
        ValueError: If the modular inverse does not exist (a and m are not coprime).
    """
    a = mpz(a)
    m = mpz(m)
    gcd, x, y = extended_gcd(a, m)
    
    if gcd != 1:
        raise ValueError(f"Modular inverse does not exist: gcd({a}, {m}) = {gcd} != 1. "
                         f"'{a}' and '{m}' must be coprime.")
    return x % m # Ensure the result is positive and within [0, m-1]

def chinese_remainder(n_list, a_list):
    """
    Solves the Chinese Remainder Theorem (CRT).
    Given a list of moduli n_list = [n1, n2, ...] and a list of remainders a_list = [a1, a2, ...],
    finds the smallest non-negative integer x such that x = a_i (mod n_i) for all i.
    Uses gmpy2.mpz for arbitrary precision integers.

    Args:
        n_list (list): A list of coprime moduli (mpz objects or integers).
        a_list (list): A list of corresponding remainders (mpz objects or integers).

    Returns:
        mpz: The solution x.

    Raises:
        ValueError: If input lists are invalid.
    """
    if not isinstance(n_list, list) or not isinstance(a_list, list) or len(n_list) != len(a_list):
        raise ValueError("n_list and a_list must be lists of the same length.")

    # Calculate the product of all moduli (M)
    M = mpz(1)
    for n_i in n_list:
        M *= mpz(n_i)

    x = mpz(0) # Initialize the solution x
    
    # Iterate through each congruence x = a_i (mod n_i)
    for a_i, n_i in zip(a_list, n_list):
        m_i = mpz(n_i) # Current modulus
        a_i = mpz(a_i) # Current remainder
        
        # Calculate M_i = M / m_i (product of all moduli except m_i)
        M_i = M // m_i
        
        # Calculate y_i, which is the modular inverse of M_i modulo m_i
        y_i = mod_inverse(M_i, m_i)
        
        # Update the running sum for x: x = sum (a_i * M_i * y_i) mod M
        x = (x + a_i * M_i * y_i) % M
    return x

def naive_pohlig_hellman(g, y, p, distinct_prime_factors_of_exponent_modulus):
    """
    Solves the discrete logarithm g^x = y (mod p) using a simplified Pohlig-Hellman approach.
    This function computes x modulo the product of `distinct_prime_factors_of_exponent_modulus`.

    Args:
        g (mpz): The base of the discrete logarithm.
        y (mpz): The target value.
        p (mpz): The prime modulus (field Z_p^*).
        distinct_prime_factors_of_exponent_modulus (list): A list of distinct prime factors
            of the order of the group in which 'x' is being solved. For this challenge,
            this is typically the prime factors of (p-1)/2 or (q-1)/2.

    Returns:
        mpz: The partial solution for x (e.g., x mod ((p-1)//2)).

    Raises:
        ValueError: If dlog_brute fails for any subgroup, indicating an issue.
    """
    congruences = [] # This list will store (remainder, modulus) pairs for CRT

    # Calculate the effective modulus for the exponent 'x'
    # This is the product of all distinct_prime_factors_of_exponent_modulus.
    effective_exponent_modulus = mpz(1)
    for q_i in distinct_prime_factors_of_exponent_modulus:
        effective_exponent_modulus *= mpz(q_i)

    # If the effective modulus is 1 (meaning no factors or modulus was 1),
    # the exponent must be 0 (modulo 1, any x is 0).
    if effective_exponent_modulus == 1:
        return mpz(0)

    # For each distinct prime factor q_i of the effective_exponent_modulus
    for q_i in distinct_prime_factors_of_exponent_modulus:
        # Calculate intermediate base g_prime and target y_prime.
        # These are elements in a subgroup of Z_p^* with order q_i.
        # g_prime = g^((p-1)/q_i) mod p
        # y_prime = y^((p-1)/q_i) mod p
        # (p-1) is the order of the multiplicative group Z_p^*.
        
        # Using the custom powmod_base_list for efficient modular exponentiation
        g_prime = powmod_base_list(g, (p - 1) // q_i, p)
        y_prime = powmod_base_list(y, (p - 1) // q_i, p)

        # Solve the reduced discrete logarithm problem: g_prime^x_i = y_prime (mod p)
        # The solution x_i will be the value of x modulo q_i.
        try:
            # The order of g_prime in this context is q_i, so we pass q_i as order_limit
            x_i = dlog_brute(g_prime, y_prime, p, q_i)
            congruences.append((x_i, q_i))
        except ValueError as e:
            # If dlog_brute fails, it indicates a problem (e.g., y_prime is not in the subgroup
            # generated by g_prime, or the order_limit was incorrect).
            print(f"Warning: dlog_brute failed for prime factor q_i={q_i}. Error: {e}")
            raise # Re-raise the error to signal a critical issue in the algorithm flow

    # Combine all individual congruences (x = x_i mod q_i) using the Chinese Remainder Theorem
    remainders = [c[0] for c in congruences]
    moduli = [c[1] for c in congruences]
    
    # The result 'x_partial' is the solution modulo effective_exponent_modulus
    x_partial = chinese_remainder(moduli, remainders)
    return x_partial

# --- Main Script to Solve NSA Backdoor Challenge ---

print("Starting PicoCTF NSA Backdoor Solver script...")

# Dictionary to store variables read from 'output.txt'
vars={}
output_file_name = "output.txt"

# Attempt to read 'n' and 'c' from 'output.txt'
try:
    with open(output_file_name) as f:
        print(f"Reading variables from '{output_file_name}'...")
        # Each line is expected to be "key = 0xhexvalue"
        for k,v in [x.strip().split(" = ") for x in f]:
            vars[k] = mpz(v,16) # Convert hex string (e.g., '0x...') to mpz integer
    print("Variables 'n' and 'c' loaded successfully.")
except FileNotFoundError:
    print(f"Error: '{output_file_name}' not found. Please ensure it is in the same directory as the script.")
    print("This script requires 'output.txt' containing 'n = 0x...' and 'c = 0x...' values from the challenge.")
    exit() # Exit if the input file is not found

# Define variables of interest from the loaded data
n, c = vars["n"], vars["c"]
g = mpz(3) # The base 'g' is typically 3 in this type of RSA-like challenge

print(f"\n--- Given Challenge Parameters ---")
print(f"n (modulus) = {hex(n)}")
print(f"c (ciphertext) = {hex(c)}")
print(f"g (base) = {g}")

# Factor n into its prime factors p and q
print("\n--- Step 1: Factoring n into p and q ---")
try:
    # Use primefac.pollard_pm1 as per the original snippet for faster factorization
    # if n has specific prime factor properties.
    p = primefac.pollard_pm1(n)
    
    # Validate the result from pollard_pm1
    if p is None or p == 1 or p == n or (n % p != 0):
        # If Pollard P-1 fails (returns None, 1, n, or a non-factor),
        # fall back to general prime factorization using primefac.primefac.
        print("Pollard P-1 failed to find a non-trivial factor. Trying general prime factorization (may be slower).")
        factors_of_n = list(primefac.primefac(n))
        if len(factors_of_n) == 2:
            p, q = mpz(factors_of_n[0]), mpz(factors_of_n[1])
        else:
            raise ValueError(f"Factoring 'n' into two prime factors failed. Found {len(factors_of_n)} factors: {factors_of_n}")
    else:
        q = n // p
        # Basic check to ensure factorization is valid (p*q should equal n)
        if p * q != n:
             raise ValueError("Factoring 'n' failed: p * q does not equal n.")

    print(f"n factored successfully: p = {p}, q = {q}")
    print(f"p (hex) = {hex(p)}")
    print(f"q (hex) = {hex(q)}")

except Exception as e:
    print(f"Error during factorization of 'n': {e}")
    print("Cannot proceed without successful factorization of 'n'. Exiting.")
    exit()

# Define two subproblems: one modulo p and one modulo q
cp = c % p
cq = c % q
print(f"\n--- Step 2: Defining Subproblems ---")
print(f"c_p (ciphertext mod p) = {cp}")
print(f"c_q (ciphertext mod q) = {cq}")

# --- Step 3: Solve Discrete Logarithm modulo p ---
print(f"\n--- Step 3: Solving Discrete Logarithm mod p: g^x = cp (mod p) ---")
# The problem's structure implies solving for x mod (p-1)//2 first, then combining with x mod 2.
phi_p_minus_1_half = (p - 1) // 2

if phi_p_minus_1_half < 1:
    print(f"Error: (p-1)//2 resulted in a value less than 1. p={p}")
    exit()

# Get distinct prime factors of (p-1)//2 for the Pohlig-Hellman algorithm
distinct_prime_factors_of_p_minus_1_half = list(set(primefac.primefac(phi_p_minus_1_half)))
distinct_prime_factors_of_p_minus_1_half.sort() # Sort for consistent output

print(f"Distinct prime factors of (p-1)//2 ({phi_p_minus_1_half}): {distinct_prime_factors_of_p_minus_1_half}")

# Solve for xp, which is x mod ((p-1)//2)
xp = naive_pohlig_hellman(g, cp, p, distinct_prime_factors_of_p_minus_1_half)
print(f"Partial solution mod p (xp = x mod {phi_p_minus_1_half}): {xp}")

# Solve for all possible solutions modulo p (there are 2 due to the 'mod 2' part)
# XP0: x = xp (mod (p-1)//2) AND x = 0 (mod 2)
# XP1: x = xp (mod (p-1)//2) AND x = 1 (mod 2)
XP0 = chinese_remainder([phi_p_minus_1_half, 2], [xp, 0])
XP1 = chinese_remainder([phi_p_minus_1_half, 2], [xp, 1])

# Verify the calculated solutions by checking g^X = cp (mod p)
assert powmod_base_list(g,XP0,p) == cp, f"Assertion failed: XP0 is not a solution mod p! Calculated: {powmod_base_list(g,XP0,p)}, Expected: {cp}"
assert powmod_base_list(g,XP1,p) == cp, f"Assertion failed: XP1 is not a solution mod p! Calculated: {powmod_base_list(g,XP1,p)}, Expected: {cp}"
print(f"Full solutions mod p found: XP0={XP0}, XP1={XP1}")

# --- Step 4: Solve Discrete Logarithm modulo q ---
print(f"\n--- Step 4: Solving Discrete Logarithm mod q: g^x = cq (mod q) ---")
# Similar to step 3, solve for x mod ((q-1)//2)
phi_q_minus_1_half = (q - 1) // 2

if phi_q_minus_1_half < 1:
    print(f"Error: (q-1)//2 resulted in a value less than 1. q={q}")
    exit()

# Get distinct prime factors of (q-1)//2 for Pohlig-Hellman
distinct_prime_factors_of_q_minus_1_half = list(set(primefac.primefac(phi_q_minus_1_half)))
distinct_prime_factors_of_q_minus_1_half.sort() # Sort for consistent output

print(f"Distinct prime factors of (q-1)//2 ({phi_q_minus_1_half}): {distinct_prime_factors_of_q_minus_1_half}")

# Solve for xq, which is x mod ((q-1)//2)
xq = naive_pohlig_hellman(g, cq, q, distinct_prime_factors_of_q_minus_1_half)
print(f"Partial solution mod q (xq = x mod {phi_q_minus_1_half}): {xq}")

# Solve for all possible solutions modulo q (there are 2 due to the 'mod 2' part)
XQ0 = chinese_remainder([phi_q_minus_1_half, 2], [xq, 0])
XQ1 = chinese_remainder([phi_q_minus_1_half, 2], [xq, 1])

# Verify the calculated solutions by checking g^X = cq (mod q)
assert powmod_base_list(g,XQ0,q) == cq, f"Assertion failed: XQ0 is not a solution mod q! Calculated: {powmod_base_list(g,XQ0,q)}, Expected: {cq}"
assert powmod_base_list(g,XQ1,q) == cq, f"Assertion failed: XQ1 is not a solution mod q! Calculated: {powmod_base_list(g,XQ1,q)}, Expected: {cq}"
print(f"Full solutions mod q found: XQ0={XQ0}, XQ1={XQ1}")


# --- Step 5: Combine solutions using Chinese Remainder Theorem ---
print("\n--- Step 5: Trying all 4 combinations with Chinese Remainder Theorem to find final solution mod n ---")
found_message = False

# Iterate through all 4 pairs of (solution mod p, solution mod q)
for a,b in itertools.product([XP0,XP1],[XQ0,XQ1]):
    # Solve the system: x = a (mod p) and x = b (mod q)
    s = chinese_remainder([p,q],[a,b])
    
    # Check if the found 's' satisfies the original equation g^s = c (mod n)
    if powmod_base_list(g,s,n) == c:
        # Additional sanity check to ensure the solution also satisfies the modular equations
        assert powmod_base_list(g,s,p) == cp and powmod_base_list(g,s,q) == cq, "Internal Error: Solution did not satisfy mod p and mod q."
        
        print("\n--- Solution Found! ---")
        print(f"Exponent s = {s}")
        print(f"Exponent s (hex) = {hex(s)}")

        # Convert the numerical solution 's' back into a readable message (flag)
        hex_s = s.digits(16) # Get the hex string representation from the mpz object (e.g., '61706c6167')
        
        # unhexlify requires an even number of hex digits. Pad with a leading '0' if needed.
        if len(hex_s) % 2 != 0:
            hex_s = '0' + hex_s 

        try:
            # unhexlify expects a bytes-like object, so encode the hex string (e.g., '61706c6167' -> b'61706c6167')
            message_bytes = unhexlify(hex_s.encode('utf-8'))
            # Decode the bytes to a UTF-8 string. 'errors=ignore' handles non-UTF-8 characters gracefully.
            message = message_bytes.decode('utf-8', errors='ignore') 
            print(f"\nFound Message:\nm='{message}'")
            print(f"(Original hex value of message: 0x{hex_s})")
        except Exception as e:
            print(f"\nFound solution s={s}, but failed to decode message from hex '0x{hex_s}': {e}")
            print("The value 's' itself is the numeric representation of the flag.")
            print(f"s (decimal) = {s}")
            print(f"s (hex)     = 0x{hex_s}")
        
        found_message = True
        break # Exit the loop once the correct message (flag) is found

if not found_message:
    print("\nNo valid message found after trying all combinations. Please check the 'output.txt' file, or review the algorithm's assumptions.")
