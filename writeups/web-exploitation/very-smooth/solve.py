from gmpy2 import mpz, gcd, powmod, invert
from math import gcd as math_gcd
from binascii import unhexlify
from itertools import product

# קריאת n ו-c מ-output.txt
with open('output.txt') as f:
    lines = f.read().splitlines()
n = mpz(next(l.split('=')[1].strip() for l in lines if l.startswith('n')), 16)
c = mpz(next(l.split('=')[1].strip() for l in lines if l.startswith('c')), 16)
e = 0x10001

# Pollard's p-1 לפקטוריזציה
def pollards_p1(N, B=2**16):
    a = mpz(2)
    for j in range(2, B):
        a = powmod(a, j, N)
    return gcd(a-1, N)

print("[*] Factoring n...")
p = pollards_p1(n)
q = n // p
print("[+] p, q found!")

# חישוב λ(n) ו-g
lam = (p-1)*(q-1)//math_gcd(p-1, q-1)
g = math_gcd(e, lam)

# מחשבים את FLAG^g
d = invert(e//g, lam//g)
m_g = powmod(c, d, n)

# שורש g-י מוד u (לג׳ וג׳) — יעיל ללא חיפוש длинный
def gth_root_mod(a, g, u):
    return powmod(a, invert(g, u-1), u)

rp = gth_root_mod(m_g, g, p)
rq = gth_root_mod(m_g, g, q)

# CRT לשילוב בין שתי השרשים
inv_q = invert(q, p)
m = (rq + q * ((rp - rq) * inv_q % p)) % n

# קבלת FLAG
flag = unhexlify(hex(m)[2:]).decode()
print("[+] Flag:", flag)
